import json
import pymongo
from datetime import datetime
import ast
import os

# CONFIGURATION
MONGO_URI = "mongodb://localhost:27017/"
DB_NAME = "large_bnb_db"

# FOLDER PATH (Modify this if necessary)
BASE_DIR = r'C:\Users\Utente\Desktop\DatasetScript'

def load_json(filename):
    full_path = os.path.join(BASE_DIR, filename)
    try:
        with open(full_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"WARNING: Cannot find file {filename} in {BASE_DIR}. Checking if I can continue...")
        return []

def clean_amenities(amenities_field):
    """Cleans the amenities field from dirty scraping data"""
    clean_list = []
    
    if isinstance(amenities_field, list):
        for item in amenities_field:
            clean_item = item.replace('[', '').replace(']', '').replace('"', '').replace('\\', '').strip()
            if clean_item:
                clean_list.append(clean_item)
        return clean_list
    
    if isinstance(amenities_field, str):
        try:
            return ast.literal_eval(amenities_field.replace('\\"', '"'))
        except:
            return []
            
    return amenities_field if amenities_field else []

def main():
    client = pymongo.MongoClient(MONGO_URI)
    db = client[DB_NAME]
    
    print("--- 1. Loading JSON files into memory ---")
    raw_properties = load_json(r'C:\Users\Utente\Desktop\Progetto LSMD\ScriptPopulatingDB\properties.json')
    raw_rooms = load_json(r'C:\Users\Utente\Desktop\Progetto LSMD\ScriptPopulatingDB\rooms.json')
    raw_reviews = load_json(r'C:\Users\Utente\Desktop\Progetto LSMD\ScriptPopulatingDB\reviews.json')
    raw_customers = load_json(r'C:\Users\Utente\Desktop\Progetto LSMD\ScriptPopulatingDB\customers.json')
    raw_managers = load_json(r'C:\Users\Utente\Desktop\Progetto LSMD\ScriptPopulatingDB\managers.json')
    raw_reservations = load_json(r'C:\Users\Utente\Desktop\Progetto LSMD\ScriptPopulatingDB\reservations.json')
    raw_messages = load_json(r'C:\Users\Utente\Desktop\Progetto LSMD\ScriptPopulatingDB\messages.json')
    
    # If main files are missing, stop
    if not raw_properties: 
        print("Critical error: properties.json missing or empty.")
        return

    print("--- 2. Merging Users (Customer + Manager) with EMAIL DEDUPLICATION ---")
    users_collection = []
    seen_emails = set()
    
    # Processing Customers
    for c in raw_customers:
        email = c.get('email')
        if email in seen_emails:
            continue
        seen_emails.add(email)
        c['role'] = 'CUSTOMER'
        c['_id'] = c.pop('id')
        users_collection.append(c)
        
    # Processing Managers
    for m in raw_managers:
        email = m.get('email')
        if email in seen_emails:
            continue
        seen_emails.add(email)
        m['role'] = 'MANAGER'
        m['_id'] = m.pop('id')
        users_collection.append(m)
    
    db.users.delete_many({}) 
    if users_collection:
        db.users.insert_many(users_collection)
    print(f"Inserted {len(users_collection)} unique users.")

    print("--- 3. Building Properties (Embedding Rooms + Stats + Reviews) ---")
    
    # Fast map Rooms -> Property
    rooms_by_property = {}
    if raw_rooms:
        for r in raw_rooms:
            pid = r.get('property_id')
            if not pid: continue
            if pid not in rooms_by_property: rooms_by_property[pid] = []
            r['roomId'] = r.pop('id') 
            if 'property_id' in r: del r['property_id']
            rooms_by_property[pid].append(r)

    # Fast map Reviews -> Property and date calculation
    reviews_by_property = {}
    if raw_reviews:
        for rv in raw_reviews:
            pid = rv.get('property_id')
            if not pid: continue
            if pid not in reviews_by_property: reviews_by_property[pid] = []
            
            # Review date parsing
            try:
                # Try ISO format (generated by new script) or simple format
                rv['date'] = datetime.fromisoformat(rv['creationDate'])
            except ValueError:
                try:
                    rv['date'] = datetime.strptime(rv['creationDate'], "%Y-%m-%d")
                except:
                    rv['date'] = datetime.now()
            
            reviews_by_property[pid].append(rv)

    properties_final = []
    reviews_final_collection = []

    for prop in raw_properties:
        p_id = prop['id']
        new_prop = prop.copy()
        new_prop['_id'] = p_id
        if 'id' in new_prop: del new_prop['id']
        
        # Amenities cleaning
        if 'amenities' in new_prop:
            new_prop['amenities'] = clean_amenities(new_prop['amenities'])

        # Embedding Rooms
        new_prop['rooms'] = rooms_by_property.get(p_id, [])
        
        # Handling Reviews and Statistics
        prop_reviews = reviews_by_property.get(p_id, [])
        prop_reviews.sort(key=lambda x: x['date'], reverse=True)
        
        # Detailed Averages Calculation
        stats = {
            "average": 0.0,
            "count": 0,
            "cleanliness": 0.0,
            "communication": 0.0,
            "location": 0.0,
            "value": 0.0
        }

        if prop_reviews:
            total_rating = 0
            total_clean = 0
            total_comm = 0
            total_loc = 0
            total_val = 0
            count = len(prop_reviews)

            for r in prop_reviews:
                total_rating += r.get('rating', 0)
                # Use .get(key, global_rating) as fallback if field is missing
                total_clean += r.get('cleanliness', r.get('rating', 0))
                total_comm += r.get('communication', r.get('rating', 0))
                total_loc += r.get('location', r.get('rating', 0))
                total_val += r.get('value', r.get('rating', 0))

            stats["average"] = round(total_rating / count, 1)
            stats["cleanliness"] = round(total_clean / count, 1)
            stats["communication"] = round(total_comm / count, 1)
            stats["location"] = round(total_loc / count, 1)
            stats["value"] = round(total_val / count, 1)
            stats["count"] = count

        new_prop['ratingStats'] = stats

        # Creating "latestReviews" subset (embedded in property)
        top_5 = []
        for rv in prop_reviews[:5]:
            subset_doc = {
                "userDisplayName": "Guest User", 
                "rating": rv.get('rating'),
                "text": (rv.get('text') or "")[:100] + "...", 
                "date": rv['date']
            }
            top_5.append(subset_doc)
        
        new_prop['latestReviews'] = top_5

        # Preparing documents for separate 'reviews' collection
        for rv in prop_reviews:
            rv_doc = rv.copy()
            if 'id' in rv_doc: rv_doc['_id'] = rv_doc.pop('id')
            rv_doc['propertyId'] = p_id
            if 'property_id' in rv_doc: del rv_doc['property_id']
            # Fields cleanliness, communication etc. are already inside rv_doc
            reviews_final_collection.append(rv_doc)

        properties_final.append(new_prop)

    # Inserting Properties
    db.properties.delete_many({})
    if properties_final:
        db.properties.insert_many(properties_final)
    print(f"Inserted {len(properties_final)} properties.")

    # Inserting Reviews (Separate Collection)
    db.reviews.delete_many({})
    if reviews_final_collection:
        db.reviews.insert_many(reviews_final_collection)
    print(f"Inserted {len(reviews_final_collection)} total reviews.")

    print("--- 4. Handling Reservations ---")
    reservations_final = []
    if raw_reservations:
        for res in raw_reservations:
            if 'id' in res: res['_id'] = res.pop('id')
            if 'customer_id' in res: res['userId'] = res.pop('customer_id')
            if 'room_id' in res: res['roomId'] = res.pop('room_id') 
            
            try:
                if 'checkInDate' in res:
                    res['dates'] = {
                        "checkIn": datetime.fromisoformat(res['checkInDate']),
                        "checkOut": datetime.fromisoformat(res['checkOutDate'])
                    }
                    del res['checkInDate']
                    del res['checkOutDate']
            except ValueError:
                 # Fallback for old formats if necessary
                 pass
            reservations_final.append(res)
        
    db.reservations.delete_many({})
    if reservations_final:
        db.reservations.insert_many(reservations_final)
    print(f"Inserted {len(reservations_final)} reservations.")

    print("--- 5. Handling Messages ---")
    messages_final = []
    if raw_messages:
        for msg in raw_messages:
            if 'id' in msg: msg['_id'] = msg.pop('id')
            
            # Timestamp Conversion
            if 'timestamp' in msg:
                try:
                    msg['timestamp'] = datetime.fromisoformat(msg['timestamp'])
                except ValueError:
                    msg['timestamp'] = datetime.now()
            
            # Ensure ID references are consistent
            
            messages_final.append(msg)
            
    db.messages.delete_many({})
    if messages_final:
        db.messages.insert_many(messages_final)
    print(f"Inserted {len(messages_final)} messages.")

    print("\n--- ALL COMPLETED SUCCESSFULLY! ---")

if __name__ == "__main__":
    main()